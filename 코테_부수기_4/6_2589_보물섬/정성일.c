#include <stdio.h>
#include <stdlib.h>

void BFS (int** map, int** que, int* que_index, int* time) {
	int i, j, k;
	int x, y;
	int new_tail = que_index[1];

	//////////////////////////////////////////////
	// BFS
	//////////////////////////////////////////////
	for (i = que_index[0]; i <= que_index[1]; i++) {
		x = que[i][0];  //큐의 정점들
		y = que[i][1];
		for (j = -1; j < 2; j++) {
			for (k = -1; k < 2; k++) {
				if (j * k == 0 && j + k != 0) {
					if (map[x + j][y + k] == 0) {  //이동가능한 정점
						map[x + j][y + k] = 1;  //방문 표시
						new_tail++;  //큐에 추가
						que[new_tail][0] = x + j;
						que[new_tail][1] = y + k;
					}
				}
			}
		}
	}
	if (que_index[1] == new_tail) {  //더이상 추가되는 정점 없으면 종료
		return 0;
	}
	*time = *time + 1;  //시간+1
	que_index[0] = que_index[1] + 1; //큐 head tail 수정
	que_index[1] = new_tail;
	BFS(map, que, que_index, time);  //다음 단계

	return 0;
}

int main() {
	int m, n;
	int i, j, k, l;
	int** map;
	int** que;
	int* que_index;
	int* time;
	int max_time = 0;
	char ch_temp;

	//////////////////////////////////////////////
	// 지도 크기 입력
	//////////////////////////////////////////////
	scanf("%d %d", &n, &m);

	//////////////////////////////////////////////
	// 변수 할당
	//////////////////////////////////////////////
	time = (int*)malloc(sizeof(int));  //시간
	
	//////////////////////////////////////////////
	// 큐
	//////////////////////////////////////////////
	que = (int**)malloc(sizeof(int*) * (n * m));  //큐
	for (i = 0; i < n * m; i++) {
		que[i] = (int*)malloc(sizeof(int) * 2);
	}
	que_index = (int*)malloc(sizeof(int) * 2);  //큐 head tail

	//////////////////////////////////////////////
	// 지도
	//////////////////////////////////////////////
	map = (int**)malloc(sizeof(int*) * (n + 2));  //지도
	for (i = 0; i <= n+1; i++) {
		map[i] = (int*)malloc(sizeof(int) * (m + 2));
		for (j = 0; j <= m+1; j++) {
			if (i == 0 || j == 0 || i == n + 1 || j == m + 1) {  //테두리 -1표시
				map[i][j] = -1;
			}
			else {
				scanf(" %c", &ch_temp);  //문자 입력
				if (ch_temp == 'W') {  //바다 -1 표시
					map[i][j] = -1;
				}
				else if (ch_temp == 'L') {  //육지 0 표시
					map[i][j] = 0;
				}
			}
		}
	}

	//////////////////////////////////////////////
	// 모든 정점에서 BFS 시도
	//////////////////////////////////////////////
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) {
			if (map[i][j] == 0) {  //육지인 정점이면
				//////////////////////////////////////////////
				// 초기화
				//////////////////////////////////////////////
				que_index[0] = 0;  //큐 head tail 초기화
				que_index[1] = 0;
				que[que_index[0]][0] = i;  //시작점 큐 추가
				que[que_index[0]][1] = j;
				map[i][j] = 1;  //방문 기록
				*time = 0;  //시간 초기화

				//////////////////////////////////////////////
				// BFS
				//////////////////////////////////////////////
				BFS(map, que, que_index, time);  //BFS

				//////////////////////////////////////////////
				// 방문기록 초기화
				//////////////////////////////////////////////
				for (k = 1; k <= n; k++) {  //맵 방문기록 초기화
					for (l = 1; l <= m; l++) {
						if (map[k][l] == 1) {
							map[k][l] = 0;
						}
					}
				}
				//////////////////////////////////////////////
				// 최대시간 저장
				//////////////////////////////////////////////
				if (max_time < *time) {
					max_time = *time;
				}
			}
		}
	}

	//////////////////////////////////////////////
	// 결과 출력
	//////////////////////////////////////////////
	printf("%d", max_time);

	//////////////////////////////////////////////
	// 할당 해제
	//////////////////////////////////////////////
	for (i = 0; i < n * m; i++) {
		free(que[i]);
	}
	free(que);
	for (i = 0; i <= n + 1; i++) {
		free(map[i]);
	}
	free(map);
	free(que_index);
	free(time);

	return 0;
}
