#include <stdio.h>
#include <stdlib.h>
#include <string>

/////////////////////////////////////////////////////////////
// 트리 노드 구조체
/////////////////////////////////////////////////////////////
struct Node {
	int data;  // 데이터 부분
	//끝점은 1, 경유점은 0
	struct Node** tree;  //간선 10개를 일일히 지정해주기 싫어서 이중포인터 사용
	// 간선은 기본적으로 없는 상태이고 들어갈때 생성 
};

/////////////////////////////////////////////////////////////
// 트리 노드 생성
/////////////////////////////////////////////////////////////
struct Node* add_node(){
	struct Node* new_node;
	int i;

	new_node=(struct Node*)malloc(sizeof(struct Node));  // 노드 할당
	new_node->data = 0;  // 노드 데이터
	new_node->tree = (struct Node**)malloc(sizeof(struct Node*) * 10);  // 간선 할당
	for (i = 0; i < 10; i++) {
		new_node->tree[i] = NULL;  // 간선을 NULL(없는것)으로 기본 설정
	}

	return new_node;
}

/////////////////////////////////////////////////////////////
// 트리 노드 할당 해제
/////////////////////////////////////////////////////////////
void free_node(struct Node* node) {
	int i;

	if (node != NULL) {  // 노드가 있으면
		for (i = 0; i < 10; i++) {  // 간선이 있는지 검사
			if (node->tree[i] != NULL) {
				free_node(node->tree[i]);  // 간선이 있으면 이동
			}
		}
		free(node);  // 노드 할당 해제
	}
}

/////////////////////////////////////////////////////////////
// 트리 진입
/////////////////////////////////////////////////////////////
int go_tree(struct Node* focus, char num[10]) {
	char new_num[11];
	char ch_branch[2];
	int branch;
	int i, j;

	/////////////////////////////////////////////////////////////
	// 다른 전화번호 트리를 포함하게 되면
	/////////////////////////////////////////////////////////////
	if (focus->data == 1) {
		return 1;  //결과는 NO로 종료
	}

	/////////////////////////////////////////////////////////////
	// 트리 끝에 도달하면
	/////////////////////////////////////////////////////////////
	if (num[0] == '\0') {
		for (i = 0; i < 10; i++) {  // 간선이 있는지 확인하면
			if (focus->tree[i] != NULL) {  // 지나갔던 트리가 있는지 확인 가능
				return 1;  // 있으면 NO로 종료
			}
		}
		focus->data = 1;  // 문제가 없으면 트리 끝임을 저장
		return 0;
	}

	/////////////////////////////////////////////////////////////
	// 맨앞문자 정수화
	/////////////////////////////////////////////////////////////
	ch_branch[0] = num[0];
	ch_branch[1] = '\0';
	branch = atoi(ch_branch);

	/////////////////////////////////////////////////////////////
	// 문자열 맨 앞을 제거
	/////////////////////////////////////////////////////////////
	for (i = 0; i < 10; i++) {
		new_num[i]=num[i+1];
	}

	/////////////////////////////////////////////////////////////
	// 간선이 없으면 생성후 진입
	/////////////////////////////////////////////////////////////
	if (focus->tree[branch] == NULL) {
		focus->tree[branch] = add_node();
	}
	return go_tree(focus->tree[branch], new_num);
}

int main() {
	int t_c;  // test case
	int n;  // 전화번호 갯수
	int result;  // 결과 저장
	struct Node* s_tree = NULL;  // 노드 주소
	int i;  // 반복문 변수
	char ip_num[11];  // 전화번호 입력

	scanf("%d", &t_c);  // 테스트 횟수 입력
	for (; t_c > 0; t_c--) {  // 반복
		/////////////////////////////////////////////////////////////
		// 초기화
		/////////////////////////////////////////////////////////////
		s_tree = add_node();  // 트리 시작점 만들기
		result = 0;  // 결과값 초기화
		/////////////////////////////////////////////////////////////
		// 전화번호 입력
		/////////////////////////////////////////////////////////////
		scanf("%d", &n);  // 전화번호갯수 입력
		for (i = 0; i < n; i++) {  // 반복
			scanf("%s", ip_num);  // 전화번호 입력
			/////////////////////////////////////////////////////////////
			// 트리 만들기
			/////////////////////////////////////////////////////////////
			if (result==0) {  //결과가 NO가 아니면
				result = go_tree(s_tree, ip_num);  // 트리진입
			}
		}
		/////////////////////////////////////////////////////////////
		// 결과 출력
		/////////////////////////////////////////////////////////////
		if (result) {
			printf("NO\n");
		}
		else {
			printf("YES\n");
		}
		/////////////////////////////////////////////////////////////
		// 할당 해제
		/////////////////////////////////////////////////////////////
		free(s_tree);
	}

	return 0;
}
